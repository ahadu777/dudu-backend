name: Railway PR Preview

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

env:
  RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
  RAILWAY_PROJECT_ID: ${{ secrets.RAILWAY_PROJECT_ID }}

jobs:
  preview:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install Railway CLI and jq
        run: |
          curl -fsSL https://railway.app/install.sh | sh
          echo "$HOME/.railway/bin" >> $GITHUB_PATH
          sudo apt-get update && sudo apt-get install -y jq

      - name: Deploy PR Preview
        id: deploy
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_BRANCH: ${{ github.head_ref }}
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          RAILWAY_PROJECT_ID: ${{ secrets.RAILWAY_PROJECT_ID }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
        run: |
          SERVICE_NAME="api-pr-${PR_NUMBER}"
          
          echo "üöÄ Deploying to service: ${SERVICE_NAME}"
          
          # Verify Railway token is set
          if [ -z "$RAILWAY_TOKEN" ]; then
            echo "‚ùå RAILWAY_TOKEN is not set"
            exit 1
          fi
          
          echo "‚úÖ RAILWAY_TOKEN is set (length: ${#RAILWAY_TOKEN})"
          echo "‚úÖ RAILWAY_PROJECT_ID: ${RAILWAY_PROJECT_ID}"
          
          # Create railway.toml with project ID for Railway CLI context
          cat > railway.toml << EOF
          project = "${RAILWAY_PROJECT_ID}"
          
          [build]
          builder = "DOCKERFILE"
          
          [deploy]
          startCommand = "npm start"
          healthcheckPath = "/healthz"
          EOF
          
          echo "‚úÖ Created railway.toml with project context"
          
          # Check if service exists, create via Railway GraphQL API if it doesn't
          # NOTE: This requires an Account Token (not Project Token)
          # Project Tokens cannot create services via API
          echo "üîç Checking if service exists..."
          RAILWAY_GRAPHQL="https://backboard.railway.app/graphql/v2"
          
          # Query to list services (using correct GraphQL connection syntax)
          LIST_QUERY='{"query":"query { project(id: \"'${RAILWAY_PROJECT_ID}'\") { services { edges { node { id name } } } } }"}'
          SERVICES_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$LIST_QUERY" \
            "$RAILWAY_GRAPHQL" 2>&1 || echo '{"data":{"project":{"services":{"edges":[]}}}}')
          
          # Check for errors
          if echo "$SERVICES_RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
            echo "‚ö†Ô∏è GraphQL query failed (may need Account Token):"
            echo "$SERVICES_RESPONSE" | jq '.errors' 2>/dev/null || echo "$SERVICES_RESPONSE"
            echo ""
            echo "üí° If using Project Token, services must be created manually first."
            echo "   Trying Railway CLI deployment anyway..."
            SERVICE_EXISTS=""
          else
            SERVICE_EXISTS=$(echo "$SERVICES_RESPONSE" | jq -r ".data.project.services.edges[].node | select(.name == \"${SERVICE_NAME}\") | .id" 2>/dev/null || echo "")
          fi
          
          if [ -z "$SERVICE_EXISTS" ] || [ "$SERVICE_EXISTS" == "null" ]; then
            echo "üì¶ Service doesn't exist, attempting to create via Railway API..."
            
            # Create service via GraphQL mutation
            CREATE_MUTATION='{"query":"mutation { serviceCreate(input: {name: \"'${SERVICE_NAME}'\", projectId: \"'${RAILWAY_PROJECT_ID}'\"}) { id name } }"}'
            CREATE_RESPONSE=$(curl -s -X POST \
              -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$CREATE_MUTATION" \
              "$RAILWAY_GRAPHQL" 2>&1 || echo "")
            
            # Check if creation succeeded
            if echo "$CREATE_RESPONSE" | jq -e '.data.serviceCreate.id' > /dev/null 2>&1; then
              SERVICE_ID=$(echo "$CREATE_RESPONSE" | jq -r '.data.serviceCreate.id')
              echo "‚úÖ Service created successfully (ID: ${SERVICE_ID})"
              sleep 3
            else
              echo "‚ö†Ô∏è Service creation via API failed (requires Account Token)"
              echo "Response: ${CREATE_RESPONSE}"
              echo ""
              echo "üí° Trying Railway CLI - it may create service automatically..."
            fi
          else
            echo "‚úÖ Service already exists (ID: ${SERVICE_EXISTS})"
          fi
          
          # Get the service ID (either from creation or existing)
          FINAL_SERVICE_ID="${SERVICE_ID:-${SERVICE_EXISTS}}"
          
          if [ -z "$FINAL_SERVICE_ID" ] || [ "$FINAL_SERVICE_ID" == "null" ]; then
            echo "‚ùå No service ID available, cannot proceed"
            exit 1
          fi
          
          echo "‚úÖ Using service ID: ${FINAL_SERVICE_ID}"
          
          # Prepare repository information
          REPO_FULL="${GITHUB_REPOSITORY}"
          REPO_OWNER="${GITHUB_REPOSITORY_OWNER}"
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          echo "Repository: ${REPO_FULL} (${REPO_OWNER}/${REPO_NAME})"
          
          # Railway CLI uses RAILWAY_TOKEN environment variable automatically
          export RAILWAY_TOKEN="${RAILWAY_TOKEN}"
          
          # Connect service to GitHub repository for auto-deployment
          # Once connected, Railway will automatically deploy on commits to the PR
          echo "üîó Connecting service to GitHub repository for auto-deployment..."
          echo "   Repository: ${REPO_FULL}"
          echo "   Branch: ${PR_BRANCH:-main}"
          
          # Initialize repo connection status
          REPO_CONNECTED=false
          
          # Use the correct GraphQL mutation: serviceConnect
          # The mutation connects a service to a GitHub repository
          CONNECT_GITHUB_MUTATION='{"query":"mutation { serviceConnect(id: \"'${FINAL_SERVICE_ID}'\", input: {repo: \"'${REPO_FULL}'\", branch: \"'${PR_BRANCH:-main}'\"}) { id } }"}'
          CONNECT_GITHUB_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$CONNECT_GITHUB_MUTATION" \
            "$RAILWAY_GRAPHQL" 2>&1 || echo "")
          
          if echo "$CONNECT_GITHUB_RESPONSE" | jq -e '.data.serviceConnect.id' > /dev/null 2>&1; then
            echo "‚úÖ Service connected to GitHub repository via API!"
            echo "   Railway will auto-deploy on commits to branch: ${PR_BRANCH:-main}"
            REPO_CONNECTED=true
          else
            # Check if error is about mutation format
            if echo "$CONNECT_GITHUB_RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
              ERROR_MSG=$(echo "$CONNECT_GITHUB_RESPONSE" | jq -r '.errors[0].message' 2>/dev/null || echo "")
              echo "‚ö†Ô∏è GraphQL mutation error: ${ERROR_MSG}"
              
              # Try alternative mutation format - serviceConnect might need different input structure
              echo "üîß Trying alternative mutation format..."
              CONNECT_GITHUB_MUTATION2='{"query":"mutation { serviceConnect(input: {serviceId: \"'${FINAL_SERVICE_ID}'\", source: {repo: \"'${REPO_FULL}'\", branch: \"'${PR_BRANCH:-main}'\"}}) { id } }"}'
              CONNECT_GITHUB_RESPONSE2=$(curl -s -X POST \
                -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                -H "Content-Type: application/json" \
                -d "$CONNECT_GITHUB_MUTATION2" \
                "$RAILWAY_GRAPHQL" 2>&1 || echo "")
              
              if echo "$CONNECT_GITHUB_RESPONSE2" | jq -e '.data.serviceConnect.id' > /dev/null 2>&1; then
                echo "‚úÖ Service connected to GitHub repository via API (alternative format)!"
                REPO_CONNECTED=true
              else
                echo "‚ö†Ô∏è Both mutation formats failed"
                echo "Response: ${CONNECT_GITHUB_RESPONSE2}"
                echo "üí° Service will need manual GitHub connection in Railway dashboard"
                REPO_CONNECTED=false
              fi
            else
              echo "‚ö†Ô∏è API connection failed"
              echo "Response: ${CONNECT_GITHUB_RESPONSE}"
              REPO_CONNECTED=false
            fi
          fi
          
          # Configure service networking: Set port 8080 and generate public domain
          echo "üåê Configuring service networking (port 8080 and public domain)..."
          
          # Railway CLI uses RAILWAY_TOKEN environment variable automatically
          export RAILWAY_TOKEN="${RAILWAY_TOKEN}"
          
          # Step 1: Configure port 8080 for the service
          # Railway uses PORT environment variable (already set), but we also need to configure networking port
          echo "üîß Configuring port 8080 for service networking..."
          
          # Try to configure port via Railway API
          # Railway services need port configured in networking settings
          CONFIGURE_PORT_MUTATION='{"query":"mutation { serviceUpdate(input: {id: \"'${FINAL_SERVICE_ID}'\", port: 8080}) { id } }"}'
          CONFIGURE_PORT_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$CONFIGURE_PORT_MUTATION" \
            "$RAILWAY_GRAPHQL" 2>&1 || echo "")
          
          if echo "$CONFIGURE_PORT_RESPONSE" | jq -e '.data.serviceUpdate.id' > /dev/null 2>&1; then
            echo "‚úÖ Port 8080 configured for service"
          else
            echo "‚ö†Ô∏è Port configuration via API may not be supported"
            echo "Response: ${CONFIGURE_PORT_RESPONSE}"
            echo "üí° Port is set via PORT environment variable (already configured)"
            echo "   If needed, configure port manually in Railway dashboard ‚Üí Service Settings ‚Üí Networking"
          fi
          
          # Step 2: Generate public domain
          echo "üåê Generating public domain..."
          
          # Check if domain already exists
          DOMAIN_QUERY='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { domains { edges { node { id domain } } } } }"}'
          DOMAIN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$DOMAIN_QUERY" \
            "$RAILWAY_GRAPHQL" 2>&1 || echo "")
          
          # Check if public domain exists
          PUBLIC_DOMAIN=$(echo "$DOMAIN_RESPONSE" | jq -r '.data.service.domains.edges[].node.domain // empty' 2>/dev/null | grep -E '\.up\.railway\.app$' | head -n1 || echo "")
          
          if [ -z "$PUBLIC_DOMAIN" ] || [ "$PUBLIC_DOMAIN" == "null" ]; then
            echo "üìù No public domain found, generating one..."
            
            # Wait a moment for deployment to be ready (if deployment was just triggered)
            sleep 5
            
            # Get service's latest deployment (needed for domain creation)
            DEPLOYMENT_QUERY='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { deployments { edges { node { id } } } } }"}'
            DEPLOYMENT_RESPONSE=$(curl -s -X POST \
              -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$DEPLOYMENT_QUERY" \
              "$RAILWAY_GRAPHQL" 2>&1 || echo "")
            
            DEPLOYMENT_ID=$(echo "$DEPLOYMENT_RESPONSE" | jq -r '.data.service.deployments.edges[0].node.id // empty' 2>/dev/null || echo "")
            
            if [ -n "$DEPLOYMENT_ID" ] && [ "$DEPLOYMENT_ID" != "null" ]; then
              echo "‚úÖ Found deployment ID: ${DEPLOYMENT_ID}"
              
              # Try creating public domain via GraphQL mutation
              # Railway generates domains in format: {service-name}-production.up.railway.app
              CREATE_DOMAIN_MUTATION='{"query":"mutation { domainCreate(input: {serviceId: \"'${FINAL_SERVICE_ID}'\", deploymentId: \"'${DEPLOYMENT_ID}'\", public: true, port: 8080}) { id domain } }"}'
              CREATE_DOMAIN_RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                -H "Content-Type: application/json" \
                -d "$CREATE_DOMAIN_MUTATION" \
                "$RAILWAY_GRAPHQL" 2>&1 || echo "")
              
              if echo "$CREATE_DOMAIN_RESPONSE" | jq -e '.data.domainCreate.domain' > /dev/null 2>&1; then
                PUBLIC_DOMAIN=$(echo "$CREATE_DOMAIN_RESPONSE" | jq -r '.data.domainCreate.domain')
                echo "‚úÖ Public domain created via GraphQL: ${PUBLIC_DOMAIN}"
              else
                echo "‚ö†Ô∏è GraphQL domain creation with port failed, trying without port..."
                echo "Response: ${CREATE_DOMAIN_RESPONSE}"
                
                # Try without port parameter
                CREATE_DOMAIN_MUTATION2='{"query":"mutation { domainCreate(input: {serviceId: \"'${FINAL_SERVICE_ID}'\", deploymentId: \"'${DEPLOYMENT_ID}'\", public: true}) { id domain } }"}'
                CREATE_DOMAIN_RESPONSE2=$(curl -s -X POST \
                  -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -d "$CREATE_DOMAIN_MUTATION2" \
                  "$RAILWAY_GRAPHQL" 2>&1 || echo "")
                
                if echo "$CREATE_DOMAIN_RESPONSE2" | jq -e '.data.domainCreate.domain' > /dev/null 2>&1; then
                  PUBLIC_DOMAIN=$(echo "$CREATE_DOMAIN_RESPONSE2" | jq -r '.data.domainCreate.domain')
                  echo "‚úÖ Public domain created via GraphQL: ${PUBLIC_DOMAIN}"
                else
                  echo "‚ö†Ô∏è GraphQL domain creation failed, trying alternative mutation..."
                  
                  # Try alternative mutation format (without deploymentId)
                  CREATE_DOMAIN_MUTATION3='{"query":"mutation { domainCreate(input: {serviceId: \"'${FINAL_SERVICE_ID}'\", public: true}) { id domain } }"}'
                  CREATE_DOMAIN_RESPONSE3=$(curl -s -X POST \
                    -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                    -H "Content-Type: application/json" \
                    -d "$CREATE_DOMAIN_MUTATION3" \
                    "$RAILWAY_GRAPHQL" 2>&1 || echo "")
                  
                  if echo "$CREATE_DOMAIN_RESPONSE3" | jq -e '.data.domainCreate.domain' > /dev/null 2>&1; then
                    PUBLIC_DOMAIN=$(echo "$CREATE_DOMAIN_RESPONSE3" | jq -r '.data.domainCreate.domain')
                    echo "‚úÖ Public domain created (alternative method): ${PUBLIC_DOMAIN}"
                  else
                    echo "‚ö†Ô∏è All GraphQL methods failed"
                    echo "Response: ${CREATE_DOMAIN_RESPONSE3}"
                    echo "üí° GraphQL API doesn't support domain creation"
                    
                    # Try Railway CLI to generate domain
                    echo "üîß Trying Railway CLI to generate domain..."
                    export RAILWAY_TOKEN="${RAILWAY_TOKEN}"
                    
                    # Verify railway.toml exists
                    if [ -f railway.toml ]; then
                      echo "‚úÖ railway.toml exists"
                      cat railway.toml
                    else
                      echo "‚ö†Ô∏è railway.toml not found!"
                    fi
                    
                    # Railway CLI requires interactive authentication and doesn't work in CI/CD
                    # Railway's GraphQL API doesn't expose domain creation
                    # Railway may auto-generate domains after deployment completes
                    echo "‚ö†Ô∏è Railway CLI domain generation requires interactive authentication"
                    echo "   Railway CLI doesn't support token-based auth for domain commands in CI/CD"
                    echo ""
                    echo "üí° Railway will auto-generate domain after deployment completes"
                    echo "   Expected format: ${SERVICE_NAME}-production.up.railway.app"
                    echo ""
                    echo "   If domain is not auto-generated, generate manually:"
                    echo "   1. Go to: https://railway.app/project/${RAILWAY_PROJECT_ID}/service/${FINAL_SERVICE_ID}"
                    echo "   2. Settings ‚Üí Networking ‚Üí Public Networking"
                    echo "   3. Click 'Generate Domain' button"
                    echo "   4. Set port to 8080 if prompted"
                    echo ""
                    
                    # Set domain to expected format (Railway will generate it automatically)
                    EXPECTED_DOMAIN="${SERVICE_NAME}-production.up.railway.app"
                    PUBLIC_DOMAIN="${EXPECTED_DOMAIN}"
                    
                    # Check if domain was auto-generated by Railway
                    echo "üîç Checking if Railway auto-generated domain..."
                    sleep 5
                    CHECK_DOMAIN_AUTO='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { domains { edges { node { id domain } } } } }"}'
                    CHECK_DOMAIN_AUTO_RESPONSE=$(curl -s -X POST \
                      -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                      -H "Content-Type: application/json" \
                      -d "$CHECK_DOMAIN_AUTO" \
                      "$RAILWAY_GRAPHQL" 2>&1 || echo "")
                    
                    AUTO_DOMAIN=$(echo "$CHECK_DOMAIN_AUTO_RESPONSE" | jq -r '.data.service.domains.edges[].node.domain // empty' 2>/dev/null | grep -E '\.up\.railway\.app$' | head -n1 || echo "")
                    
                    if [ -n "$AUTO_DOMAIN" ] && [ "$AUTO_DOMAIN" != "null" ]; then
                      PUBLIC_DOMAIN="$AUTO_DOMAIN"
                      echo "‚úÖ Railway auto-generated domain: ${PUBLIC_DOMAIN}"
                    else
                      echo "‚ö†Ô∏è Domain not yet generated - Railway will create it after deployment"
                      echo "   Using expected format: ${EXPECTED_DOMAIN}"
                    fi
                    
                    DOMAIN_CLI_EXIT=0  # Don't fail the workflow - Railway will auto-generate domain
                    
                    if [ $DOMAIN_CLI_EXIT -eq 0 ]; then
                      echo "‚úÖ Railway CLI domain command executed successfully"
                      echo "Output: ${DOMAIN_CLI_OUTPUT}"
                      
                      # Wait a moment for domain to be created
                      sleep 5
                      
                      # Check if domain was created
                      CHECK_DOMAIN_CLI='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { domains { edges { node { id domain } } } } }"}'
                      CHECK_DOMAIN_CLI_RESPONSE=$(curl -s -X POST \
                        -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                        -H "Content-Type: application/json" \
                        -d "$CHECK_DOMAIN_CLI" \
                        "$RAILWAY_GRAPHQL" 2>&1 || echo "")
                      
                      CLI_DOMAIN=$(echo "$CHECK_DOMAIN_CLI_RESPONSE" | jq -r '.data.service.domains.edges[].node.domain // empty' 2>/dev/null | grep -E '\.up\.railway\.app$' | head -n1 || echo "")
                      
                      if [ -n "$CLI_DOMAIN" ] && [ "$CLI_DOMAIN" != "null" ]; then
                        PUBLIC_DOMAIN="$CLI_DOMAIN"
                        echo "‚úÖ Public domain generated via Railway CLI: ${PUBLIC_DOMAIN}"
                      else
                        # Extract domain from CLI output
                        # Railway CLI outputs: "Service Domain created:\nüöÄ https://api-pr-13-production.up.railway.app"
                        # Or: "Domains already exist on the service:\nüöÄ https://api-pr-13-production.up.railway.app"
                        DOMAIN_FROM_OUTPUT=$(echo "$DOMAIN_CLI_OUTPUT" | grep -oE 'https?://[a-zA-Z0-9-]+-production\.up\.railway\.app' | head -n1 | sed 's|https\?://||' || echo "$DOMAIN_CLI_OUTPUT" | grep -oE '[a-zA-Z0-9-]+-production\.up\.railway\.app' | head -n1 || echo "")
                        if [ -n "$DOMAIN_FROM_OUTPUT" ]; then
                          PUBLIC_DOMAIN="$DOMAIN_FROM_OUTPUT"
                          echo "‚úÖ Public domain extracted from CLI output: ${PUBLIC_DOMAIN}"
                        else
                          echo "‚ö†Ô∏è Domain not detected after Railway CLI command"
                          echo "   CLI Output: ${DOMAIN_CLI_OUTPUT}"
                          echo "   Domain may still be provisioning - check Railway dashboard"
                          echo "   Expected format: ${SERVICE_NAME}-production.up.railway.app"
                        fi
                      fi
                    else
                      echo "‚ö†Ô∏è Railway CLI domain command failed (exit code: ${DOMAIN_CLI_EXIT})"
                      echo "Output: ${DOMAIN_CLI_OUTPUT}"
                      echo ""
                      echo "üí° Troubleshooting:"
                      echo "   - Ensure RAILWAY_TOKEN is set correctly"
                      echo "   - Check if project is linked: railway link -p ${RAILWAY_PROJECT_ID}"
                      echo "   - Verify service name matches: ${SERVICE_NAME}"
                      echo ""
                      echo "   Domain will be created automatically after deployment, or manually in Railway dashboard"
                      echo "   Expected format: ${SERVICE_NAME}-production.up.railway.app"
                      echo "   After domain is created, ensure port 8080 is configured in Networking settings"
                    fi
                  fi
                fi
              fi
            else
              echo "‚ö†Ô∏è No deployment found yet"
              echo "üí° Domain will be created automatically after first deployment completes"
              echo "   Expected format: ${SERVICE_NAME}-production.up.railway.app"
              echo "   After deployment, configure port 8080 in Networking settings"
            fi
          else
            echo "‚úÖ Public domain already exists: ${PUBLIC_DOMAIN}"
          fi
          
          # Get service details to find environment ID
          echo "üîç Getting service environment ID..."
          SERVICE_QUERY='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { id name environment { id } } }"}'
          SERVICE_DETAILS=$(curl -s -X POST \
            -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$SERVICE_QUERY" \
            "$RAILWAY_GRAPHQL" 2>&1 || echo "")
          
          ENVIRONMENT_ID=$(echo "$SERVICE_DETAILS" | jq -r '.data.service.environment.id // empty' 2>/dev/null || echo "")
          
          if [ -z "$ENVIRONMENT_ID" ] || [ "$ENVIRONMENT_ID" == "null" ]; then
            echo "‚ö†Ô∏è Could not get environment ID, trying to use project default environment..."
            # Try to get default environment from project
            ENV_QUERY='{"query":"query { project(id: \"'${RAILWAY_PROJECT_ID}'\") { environments { edges { node { id name } } } } }"}'
            ENV_RESPONSE=$(curl -s -X POST \
              -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$ENV_QUERY" \
              "$RAILWAY_GRAPHQL" 2>&1 || echo "")
            ENVIRONMENT_ID=$(echo "$ENV_RESPONSE" | jq -r '.data.project.environments.edges[0].node.id // empty' 2>/dev/null || echo "")
          fi
          
          if [ -z "$ENVIRONMENT_ID" ] || [ "$ENVIRONMENT_ID" == "null" ]; then
            echo "‚ö†Ô∏è Could not determine environment ID, variables may not be set correctly"
            echo "   Service exists but deployment may need manual configuration"
          else
            echo "‚úÖ Using environment ID: ${ENVIRONMENT_ID}"
            
            # Set environment variables using Railway GraphQL API (correct format)
            echo "üìù Setting environment variables via GraphQL API..."
            
            # Set each environment variable via GraphQL mutation
            # USE_DATABASE=false enables mock mode (no database needed for PR previews)
            # PORT=8080 matches the app's default port (env.ts defaults to 8080)
            for var_pair in "NODE_ENV=preview" "PORT=8080" "PR_NUMBER=${PR_NUMBER}" "USE_DATABASE=false" "DB_NAME=myapp_pr_${PR_NUMBER}" "JWT_SECRET=preview-secret-${PR_NUMBER}"; do
              VAR_NAME="${var_pair%%=*}"
              VAR_VALUE="${var_pair#*=}"
              
              # Correct mutation format: environmentId, projectId, name (not key), value
              SET_VAR_MUTATION='{"query":"mutation { variableUpsert(input: {environmentId: \"'${ENVIRONMENT_ID}'\", projectId: \"'${RAILWAY_PROJECT_ID}'\", name: \"'${VAR_NAME}'\", value: \"'${VAR_VALUE}'\"}) }"}'
              VAR_RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                -H "Content-Type: application/json" \
                -d "$SET_VAR_MUTATION" \
                "$RAILWAY_GRAPHQL" 2>&1 || echo "")
              
              if echo "$VAR_RESPONSE" | jq -e '.data.variableUpsert == true' > /dev/null 2>&1; then
                echo "  ‚úÖ Set ${VAR_NAME}=${VAR_VALUE}"
              else
                echo "  ‚ö†Ô∏è Failed to set ${VAR_NAME}: ${VAR_RESPONSE}"
              fi
            done
          fi
          
          # Trigger initial deployment
          echo "üì¶ Triggering initial deployment..."
          
          # If repo was connected successfully, Railway should auto-deploy
          # But we'll also try to trigger deployment explicitly
          if [ "$REPO_CONNECTED" = true ]; then
            echo "‚úÖ Repository connected - Railway should auto-deploy"
            echo "‚è≥ Waiting a moment for Railway to start deployment..."
            sleep 5
            
            # Check if deployment started
            DEPLOYMENT_CHECK_QUERY='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { deployments { edges { node { id status createdAt } } } } }"}'
            DEPLOYMENT_CHECK_RESPONSE=$(curl -s -X POST \
              -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$DEPLOYMENT_CHECK_QUERY" \
              "$RAILWAY_GRAPHQL" 2>&1 || echo "")
            
            LATEST_DEPLOYMENT=$(echo "$DEPLOYMENT_CHECK_RESPONSE" | jq -r '.data.service.deployments.edges[0].node.id // empty' 2>/dev/null || echo "")
            if [ -n "$LATEST_DEPLOYMENT" ] && [ "$LATEST_DEPLOYMENT" != "null" ]; then
              echo "‚úÖ Deployment detected (ID: ${LATEST_DEPLOYMENT})"
            else
              echo "‚ö†Ô∏è No deployment detected yet - Railway may be starting it"
            fi
          else
            echo "‚ö†Ô∏è Repository not connected via API"
            echo "   Service is created and configured, but needs:"
            echo ""
            echo "   1. Connect to GitHub repo:"
            echo "      https://railway.app/project/${RAILWAY_PROJECT_ID}/service/${FINAL_SERVICE_ID}"
            echo "      Settings ‚Üí Connect GitHub repository ‚Üí ${REPO_FULL}"
            echo "      Branch: ${PR_BRANCH:-main}"
            echo ""
            echo "   2. Or manually trigger deployment:"
            echo "      Click 'Deploy' button in Railway dashboard"
            echo ""
            echo "   After connecting repo, Railway will auto-deploy on PR updates"
          fi
          
          # Trigger deployment using Railway CLI
          # Railway CLI's railway up command builds and deploys from current directory
          echo ""
          echo "üöÄ Triggering deployment via Railway CLI..."
          
          # Railway CLI needs to know which service to deploy to
          # We'll use railway up which builds from current directory
          # First, ensure Railway CLI is properly set up
          export RAILWAY_TOKEN="${RAILWAY_TOKEN}"
          
          # Try to trigger deployment using Railway CLI
          # railway up builds from current directory and deploys
          echo "üì§ Running railway up to deploy..."
          
          # Use railway up command - it should deploy from current directory
          # Railway CLI will use railway.toml for project context
          # Railway CLI requires interactive authentication and doesn't work in CI/CD
          # Railway will auto-deploy when repo is connected (already done above)
          echo "‚ö†Ô∏è Railway CLI deployment skipped - requires interactive authentication"
          echo "   Railway will auto-deploy from connected GitHub repo"
          DEPLOY_EXIT_CODE=0  # Don't fail - Railway will auto-deploy
          
          if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Railway will auto-deploy from connected repository"
            echo "   Deployment already detected: ${LATEST_DEPLOYMENT}"
          else
              echo "‚ö†Ô∏è Railway CLI deployment skipped"
            echo "   Railway will auto-deploy from connected GitHub repo"
              echo ""
            echo "üí° Railway will automatically deploy when repo is connected"
            echo "   No manual deployment needed - Railway handles it automatically"
            
            # Alternative: Try to trigger deployment by updating service source
            # This might trigger a new deployment
            UPDATE_SERVICE_MUTATION='{"query":"mutation { serviceUpdate(input: {id: \"'${FINAL_SERVICE_ID}'\", source: {repo: \"'${REPO_FULL}'\", branch: \"'${PR_BRANCH:-main}'\"}}) { id } }"}'
            UPDATE_SERVICE_RESPONSE=$(curl -s -X POST \
              -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$UPDATE_SERVICE_MUTATION" \
              "$RAILWAY_GRAPHQL" 2>&1 || echo "")
            
            if echo "$UPDATE_SERVICE_RESPONSE" | jq -e '.data.serviceUpdate.id' > /dev/null 2>&1; then
              echo "‚úÖ Service source updated - checking for deployment creation..."
              sleep 10
              
              # Check if deployment was created after service update
              CHECK_DEPLOYMENT_QUERY='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { deployments { edges { node { id status createdAt } } } } }"}'
              CHECK_DEPLOYMENT_RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                -H "Content-Type: application/json" \
                -d "$CHECK_DEPLOYMENT_QUERY" \
                "$RAILWAY_GRAPHQL" 2>&1 || echo "")
              
              NEW_DEPLOYMENT=$(echo "$CHECK_DEPLOYMENT_RESPONSE" | jq -r '.data.service.deployments.edges[0].node.id // empty' 2>/dev/null || echo "")
              if [ -n "$NEW_DEPLOYMENT" ] && [ "$NEW_DEPLOYMENT" != "null" ]; then
                DEPLOY_STATUS=$(echo "$CHECK_DEPLOYMENT_RESPONSE" | jq -r '.data.service.deployments.edges[0].node.status // empty' 2>/dev/null || echo "")
                echo "‚úÖ Deployment created! (ID: ${NEW_DEPLOYMENT}, Status: ${DEPLOY_STATUS})"
              else
                echo "‚ö†Ô∏è Service updated but no deployment detected yet"
                echo "   Railway may be processing - check dashboard for deployment"
              fi
            else
              echo "‚ö†Ô∏è Service update failed"
              echo "Response: ${UPDATE_SERVICE_RESPONSE}"
              echo ""
              echo "‚ùå Automatic deployment trigger failed"
              echo "   Service is created and configured, but needs manual deployment:"
              echo "   1. Go to: https://railway.app/project/${RAILWAY_PROJECT_ID}/service/${FINAL_SERVICE_ID}"
              echo "   2. Ensure GitHub repo is connected (Settings ‚Üí Connect GitHub repository)"
              echo "   3. Click 'Deploy' or 'Redeploy' button"
              echo ""
              echo "   After first deployment, Railway will auto-deploy on PR updates"
            fi
          fi
          
          # Wait for deployment to start and complete
          echo "‚è≥ Waiting for deployment to start..."
          sleep 20
          
          # Wait a bit more for deployment to progress (Railway may auto-generate domain after deployment)
          echo "‚è≥ Waiting for deployment to progress..."
          sleep 15
          
          # After deployment, ensure port 8080 is configured and public domain exists
          echo "üîß Finalizing networking configuration..."
          
          # Get latest deployment to ensure we have one
          FINAL_DEPLOYMENT_QUERY='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { deployments { edges { node { id status } } } } }"}'
          FINAL_DEPLOYMENT_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$FINAL_DEPLOYMENT_QUERY" \
            "$RAILWAY_GRAPHQL" 2>&1 || echo "")
          
          LATEST_DEPLOY_ID=$(echo "$FINAL_DEPLOYMENT_RESPONSE" | jq -r '.data.service.deployments.edges[0].node.id // empty' 2>/dev/null || echo "")
          
          if [ -n "$LATEST_DEPLOY_ID" ] && [ "$LATEST_DEPLOY_ID" != "null" ]; then
            echo "‚úÖ Deployment found (ID: ${LATEST_DEPLOY_ID})"
            
            # Try to generate public domain now that we have a deployment
            echo "üåê Generating public domain..."
            
            # Check if domain already exists before creating
            CHECK_EXISTING_DOMAIN='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { domains { edges { node { id domain } } } } }"}'
            EXISTING_DOMAIN_RESPONSE=$(curl -s -X POST \
              -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "$CHECK_EXISTING_DOMAIN" \
              "$RAILWAY_GRAPHQL" 2>&1 || echo "")
            
            EXISTING_DOMAIN=$(echo "$EXISTING_DOMAIN_RESPONSE" | jq -r '.data.service.domains.edges[].node.domain // empty' 2>/dev/null | grep -E '\.up\.railway\.app$' | head -n1 || echo "")
            
            if [ -n "$EXISTING_DOMAIN" ] && [ "$EXISTING_DOMAIN" != "null" ]; then
              echo "‚úÖ Public domain already exists: ${EXISTING_DOMAIN}"
            else
              echo "üìù No public domain found, creating one..."
              
              # Method 1: Try GraphQL API with deploymentId
              CREATE_DOMAIN_FINAL='{"query":"mutation { domainCreate(input: {serviceId: \"'${FINAL_SERVICE_ID}'\", deploymentId: \"'${LATEST_DEPLOY_ID}'\", public: true}) { id domain } }"}'
              CREATE_DOMAIN_FINAL_RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                -H "Content-Type: application/json" \
                -d "$CREATE_DOMAIN_FINAL" \
                "$RAILWAY_GRAPHQL" 2>&1 || echo "")
              
              if echo "$CREATE_DOMAIN_FINAL_RESPONSE" | jq -e '.data.domainCreate.domain' > /dev/null 2>&1; then
                PUBLIC_DOMAIN=$(echo "$CREATE_DOMAIN_FINAL_RESPONSE" | jq -r '.data.domainCreate.domain')
                echo "‚úÖ Public domain generated via GraphQL API: ${PUBLIC_DOMAIN}"
              else
                echo "‚ö†Ô∏è GraphQL domain creation with deploymentId failed"
                echo "Response: ${CREATE_DOMAIN_FINAL_RESPONSE}"
                
                # Method 2: Try without deploymentId
                CREATE_DOMAIN_NO_DEPLOY='{"query":"mutation { domainCreate(input: {serviceId: \"'${FINAL_SERVICE_ID}'\", public: true}) { id domain } }"}'
                CREATE_DOMAIN_NO_DEPLOY_RESPONSE=$(curl -s -X POST \
                  -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                  -H "Content-Type: application/json" \
                  -d "$CREATE_DOMAIN_NO_DEPLOY" \
                  "$RAILWAY_GRAPHQL" 2>&1 || echo "")
                
                if echo "$CREATE_DOMAIN_NO_DEPLOY_RESPONSE" | jq -e '.data.domainCreate.domain' > /dev/null 2>&1; then
                  PUBLIC_DOMAIN=$(echo "$CREATE_DOMAIN_NO_DEPLOY_RESPONSE" | jq -r '.data.domainCreate.domain')
                  echo "‚úÖ Public domain generated (without deploymentId): ${PUBLIC_DOMAIN}"
                else
                  echo "‚ö†Ô∏è GraphQL API doesn't support domainCreate mutation"
                  echo "Response: ${CREATE_DOMAIN_NO_DEPLOY_RESPONSE}"
                  
                  # Method 3: Use Railway CLI to generate domain
                  # Railway CLI's `railway domain` command can generate domains
                  echo "üîß Using Railway CLI to generate domain..."
                  export RAILWAY_TOKEN="${RAILWAY_TOKEN}"
                  
                  # Link project and service non-interactively
                  echo "üîó Linking Railway project and service..."
                  LINK_OUTPUT=$(railway link -p "${RAILWAY_PROJECT_ID}" -e production -s "${SERVICE_NAME}" 2>&1 || railway link -p "${RAILWAY_PROJECT_ID}" -e production 2>&1 || railway link -p "${RAILWAY_PROJECT_ID}" 2>&1 || echo "Link skipped")
                  echo "Link output: ${LINK_OUTPUT}"
                  
                  # Railway CLI works with railway.toml + RAILWAY_TOKEN + linked project/service
                  # Railway CLI supports -s/--service flag to specify service name
                  echo "üì§ Running: railway domain -s ${SERVICE_NAME} --port 8080"
                  DOMAIN_CLI_OUTPUT=$(railway domain -s "${SERVICE_NAME}" --port 8080 2>&1)
                  DOMAIN_CLI_EXIT=$?
                  
                  if [ $DOMAIN_CLI_EXIT -eq 0 ]; then
                    echo "‚úÖ Railway CLI domain command executed successfully"
                    echo "Output: ${DOMAIN_CLI_OUTPUT}"
                    
                    # Wait a moment for domain to be created
                    echo "‚è≥ Waiting for domain to be created..."
                    sleep 10
                    
                    # Check if domain was created
                    CHECK_DOMAIN_AFTER_CLI='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { domains { edges { node { id domain } } } } }"}'
                    CHECK_DOMAIN_AFTER_CLI_RESPONSE=$(curl -s -X POST \
                      -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                      -H "Content-Type: application/json" \
                      -d "$CHECK_DOMAIN_AFTER_CLI" \
                      "$RAILWAY_GRAPHQL" 2>&1 || echo "")
                    
                    CLI_GENERATED_DOMAIN=$(echo "$CHECK_DOMAIN_AFTER_CLI_RESPONSE" | jq -r '.data.service.domains.edges[].node.domain // empty' 2>/dev/null | grep -E '\.up\.railway\.app$' | head -n1 || echo "")
                    
                    if [ -n "$CLI_GENERATED_DOMAIN" ] && [ "$CLI_GENERATED_DOMAIN" != "null" ]; then
                      PUBLIC_DOMAIN="$CLI_GENERATED_DOMAIN"
                      echo "‚úÖ Public domain generated via Railway CLI: ${PUBLIC_DOMAIN}"
                    else
                      # Extract domain from CLI output
                      # Railway CLI outputs: "Service Domain created:\nüöÄ https://api-pr-13-production.up.railway.app"
                      # Or: "Domains already exist on the service:\nüöÄ https://api-pr-13-production.up.railway.app"
                      DOMAIN_FROM_OUTPUT=$(echo "$DOMAIN_CLI_OUTPUT" | grep -oE 'https?://[a-zA-Z0-9-]+-production\.up\.railway\.app' | head -n1 | sed 's|https\?://||' || echo "$DOMAIN_CLI_OUTPUT" | grep -oE '[a-zA-Z0-9-]+-production\.up\.railway\.app' | head -n1 || echo "")
                      if [ -n "$DOMAIN_FROM_OUTPUT" ]; then
                        PUBLIC_DOMAIN="$DOMAIN_FROM_OUTPUT"
                        echo "‚úÖ Public domain extracted from CLI output: ${PUBLIC_DOMAIN}"
                      else
                        echo "‚ö†Ô∏è Domain not detected after Railway CLI command"
                        echo "   CLI Output: ${DOMAIN_CLI_OUTPUT}"
                        echo "   Railway CLI may need service linking"
                        echo "   Domain may still be provisioning - check Railway dashboard"
                      fi
                    fi
                  else
                    echo "‚ö†Ô∏è Railway CLI domain command failed (exit code: ${DOMAIN_CLI_EXIT})"
                    echo "Output: ${DOMAIN_CLI_OUTPUT}"
                    echo ""
                    echo "üí° Troubleshooting:"
                    echo "   - Ensure RAILWAY_TOKEN is set correctly"
                    echo "   - Check if project is linked: railway link -p ${RAILWAY_PROJECT_ID}"
                    echo "   - Verify service name matches: ${SERVICE_NAME}"
                    echo ""
                    echo "   Domain generation via API/CLI failed"
                    echo "   Please generate domain manually:"
                    echo "   1. Go to: https://railway.app/project/${RAILWAY_PROJECT_ID}/service/${FINAL_SERVICE_ID}"
                    echo "   2. Settings ‚Üí Networking ‚Üí Public Networking"
                    echo "   3. Click 'Generate Domain' button"
                    echo "   4. Set port to 8080 if prompted"
                  fi
                fi
              fi
            fi
          else
            echo "‚ö†Ô∏è No deployment found yet - domain generation will be retried"
          fi
          
          # Final check and retry domain generation if needed
          echo "üîç Final verification of public domain..."
          FINAL_DOMAIN_QUERY='{"query":"query { service(id: \"'${FINAL_SERVICE_ID}'\") { domains { edges { node { id domain } } } } }"}'
          FINAL_DOMAIN_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$FINAL_DOMAIN_QUERY" \
            "$RAILWAY_GRAPHQL" 2>&1 || echo "")
          
          ACTUAL_DOMAIN=$(echo "$FINAL_DOMAIN_RESPONSE" | jq -r '.data.service.domains.edges[].node.domain // empty' 2>/dev/null | grep -E '\.up\.railway\.app$' | head -n1 || echo "")
          
          if [ -n "$ACTUAL_DOMAIN" ] && [ "$ACTUAL_DOMAIN" != "null" ]; then
            PREVIEW_URL="https://${ACTUAL_DOMAIN}"
            echo "‚úÖ Public domain verified: ${ACTUAL_DOMAIN}"
          else
            echo "‚ö†Ô∏è Public domain not found, attempting final generation..."
            
            # Final attempt: Try generating domain one more time
            if [ -n "$LATEST_DEPLOY_ID" ] && [ "$LATEST_DEPLOY_ID" != "null" ]; then
              # Try the simplest mutation format
              FINAL_DOMAIN_CREATE='{"query":"mutation { domainCreate(input: {serviceId: \"'${FINAL_SERVICE_ID}'\", public: true}) { id domain } }"}'
              FINAL_DOMAIN_CREATE_RESPONSE=$(curl -s -X POST \
                -H "Authorization: Bearer ${RAILWAY_TOKEN}" \
                -H "Content-Type: application/json" \
                -d "$FINAL_DOMAIN_CREATE" \
                "$RAILWAY_GRAPHQL" 2>&1 || echo "")
              
              if echo "$FINAL_DOMAIN_CREATE_RESPONSE" | jq -e '.data.domainCreate.domain' > /dev/null 2>&1; then
                ACTUAL_DOMAIN=$(echo "$FINAL_DOMAIN_CREATE_RESPONSE" | jq -r '.data.domainCreate.domain')
                PREVIEW_URL="https://${ACTUAL_DOMAIN}"
                echo "‚úÖ Public domain generated on final attempt: ${ACTUAL_DOMAIN}"
              else
                # Fallback to expected format
                EXPECTED_DOMAIN="${SERVICE_NAME}-production.up.railway.app"
                PREVIEW_URL="https://${EXPECTED_DOMAIN}"
                echo "‚ö†Ô∏è Domain generation via API failed"
                echo "Response: ${FINAL_DOMAIN_CREATE_RESPONSE}"
                echo ""
                echo "üí° Domain needs manual generation:"
                echo "   1. Go to: https://railway.app/project/${RAILWAY_PROJECT_ID}/service/${FINAL_SERVICE_ID}"
                echo "   2. Settings ‚Üí Networking ‚Üí Public Networking"
                echo "   3. Click 'Generate Domain' button"
                echo "   4. Set port to 8080 if prompted"
                echo "   Expected domain: ${EXPECTED_DOMAIN}"
              fi
            else
              # Fallback to expected format
              EXPECTED_DOMAIN="${SERVICE_NAME}-production.up.railway.app"
              PREVIEW_URL="https://${EXPECTED_DOMAIN}"
              echo "‚ö†Ô∏è No deployment available for domain generation"
              echo "üí° Domain will be generated automatically after deployment completes"
              echo "   Or generate manually: Settings ‚Üí Networking ‚Üí Generate Domain"
              echo "   Expected domain: ${EXPECTED_DOMAIN}"
            fi
          fi
          
          echo "url=${PREVIEW_URL}" >> $GITHUB_OUTPUT
          echo "‚úÖ Preview URL: ${PREVIEW_URL}"

      - name: Comment PR with preview URL
        uses: actions/github-script@v7
        with:
          script: |
            const url = '${{ steps.deploy.outputs.url }}';
            const pr = context.issue.number;
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: pr,
              body: `## üöÄ Preview Environment Ready\n\n**API URL:** ${url}\n\n‚ö†Ô∏è Ephemeral environment, deleted on PR close.`
            });
